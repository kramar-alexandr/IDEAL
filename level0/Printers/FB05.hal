// entirely customised
external procedure ReverseString(string,var string);
external procedure NewLineExport();
external procedure M4PadString(string,Integer,string,Boolean,var string);
external procedure ExtractObj(string,var Integer,var string);
external procedure GetVATdouble(string,var val,var val,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external function val ValFromString(string,string,string);
external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);
external function Boolean FindLocalSerialPortDevice(Integer,LongInt,string,var record LSerialPortDeviceVc);
external procedure SetPOSWindowDisplay_SendToSerialPortDevices(string,string);
//FS, Field Separator = 0x1C

function string 40 geterror(string code)
begin
	string 40 res;
	
  SetLangMode(LangLithuanian, "LIT", 0);
  
  switch(code) begin
	  case "00": res = "00 - PATVIRTINTA";
    case "01": res = "01 - KREIPKIT–S ¯ KORTEL–S LEID–J„";
    case "02": res = "02 - KREIPKIT–S ¯ KORTEL–S LEID–J„";
    case "03": res = "03 - NETEISINGAS PREKYBININKO NR.";
    case "04": res = "04 - SULAIKYKITE KORTEL¢";
		case "05": res = "05 - NEAPTARNAUTI";
		case "06": res = "06 - KLAIDA";
		case "07": res = "07 - SULAIKYKITE KORTEL¢";
		case "08": res = "08 - PATIKRINKITE DOKUMENTUS";
		case "09": res = "09 - UëKLAUSA VYKDOMA";
		case "10": res = "10 - PATVIRTINTA NE VISA SUMA";
		case "11": res = "11 - V.I.P. PATVIRTINIMAS";
		case "12": res = "12 - NEGALIMA OPERACIJA";
		case "13": res = "13 - NEGALIMA SUMA";
		case "14": res = "14 - NETEISINGAS KORTEL–S NUMERIS";
		case "15": res = "15 - N–RA TOKIO KORTEL–S LEID–JO";
		case "16": res = "16 - REIKIA ATNAUJINTI KORTEL¢";
		case "17": res = "17 - SISTEMOS KLAIDA";
		case "18": res = "18 - SISTEMOS KLAIDA";
		case "19": res = "19 - PAKARTOKITE OPERACIJ„";
		case "20": res = "20 - SISTEMOS KLAIDA";
		case "21": res = "21 - JOKIö VEIKSMö NEATLIKTA";
		case "22": res = "22 - SISTEMOS KLAIDA";
		case "23": res = "23 - OPERACIJA NEGALI BíTI ATLIKTA";
		case "24": res = "24 - FAILAS NEPALAIKOMAS GAV–JO";
		case "25": res = "25 - NEPAVYKO RASTI ¯RAáO FAILE";
		case "26": res = "26 - DUBLIUOJASI ¯RAáAS";
		case "27": res = "27 - FAILO ¯RAáO REDAGAVIMO KLAIDA";
		case "28": res = "28 - FAILAS LAIKINAI NEPRIEINAMAS";
		case "29": res = "29 - FAILO ¯RAáYMO KLAIDA";
		case "30": res = "30 - FAILO ¯RAáYMO KLAIDA";
		case "31": res = "31 - KORTEL–S PRI–M–JO KLAIDA";
		case "32": res = "32 - SISTEMOS KLAIDA";
		case "33": res = "33 - SULAIKYKITE KORTEL¢";
		case "34": res = "34 - SULAIKYKITE KORTEL¢";
		case "35": res = "35 - SULAIKYKITE KORTEL¢";
		case "36": res = "36 - SULAIKYKITE KORTEL¢";
		case "37": res = "37 - SULAIKYKITE KORTEL¢";
		case "38": res = "38 - SULAIKYKITE KORTEL¢";
		case "39": res = "39 - NENURODYTAS S„SKAITOS TIPAS";
		case "40": res = "40 - FUNKCIJA NEPALAIKOMA";
		case "41": res = "41 - SULAIKYKITE KORTEL¢";
		case "42": res = "42 - NENURODYTAS S„SKAITOS TIPAS";
		case "43": res = "43 - SULAIKYKITE KORTEL¢";
		case "44": res = "44 - NENURODYTAS S„SKAITOS TIPAS";
		case "45": res = "45 - SISTEMOS KLAIDA";
		case "46": res = "46 - SISTEMOS KLAIDA";
		case "47": res = "47 - SISTEMOS KLAIDA";
		case "48": res = "48 - SISTEMOS KLAIDA";
		case "49": res = "49 - SISTEMOS KLAIDA";
		case "50": res = "50 - SISTEMOS KLAIDA";
		case "51": res = "51 - NEPAKANKA L–áö";
		case "52": res = "52 - NENURODYTAS S„SKAITOS TIPAS";
		case "53": res = "53 - NENURODYTAS S„SKAITOS TIPAS";
		case "54": res = "54 - BAIG–SI KORTEL–S GALIOJIMAS";
		case "55": res = "55 - NETEINGAS PIN KODAS";
		case "56": res = "56 - NEëINOMA KORTEL–";
		case "57": res = "57 - KORTELEI OPERACIJA NELEISTINA";
		case "58": res = "58 - TERMINALUI OPERACIJA NELEISTINA";
		case "59": res = "59 - ¯TARIAMA KLASTOT–";
		case "60": res = "60 - SUSISIEKITE SU PRI–M–JU";
		case "61": res = "61 - IáNAUDOTAS ATSISKAITYMO LIMITAS";
		case "62": res = "62 - RIBOTO NAUDOJIMO KORTEL–";
		case "63": res = "63 - SAUGUMO PAëEIDIMAS";
		case "64": res = "64 - NETEISINGA SUMA";
		case "65": res = "65 - IáNAUDOTAS OPERACIJö LIMITAS";
		case "66": res = "66 - SUSISIEKITE SU PRI–M–JU";
		case "67": res = "67 - SULAIKYKITE KORTEL¢";
		case "68": res = "68 - SISTEMOS KLAIDA";
		case "69": res = "69 - SISTEMOS KLAIDA";
		case "70": res = "70 - SISTEMOS KLAIDA";
		case "71": res = "71 - SISTEMOS KLAIDA";
		case "72": res = "72 - SISTEMOS KLAIDA";
		case "73": res = "73 - SISTEMOS KLAIDA";
		case "74": res = "74 - SISTEMOS KLAIDA";
		case "75": res = "75 - VIRáYTAS PIN ¯VEDIMO LIMITAS";
		case "76": res = "76 - NEPAVYKSTA RASTI OPERACIJOS";
		case "77": res = "77 - KARTOJAMA AR ATáAUKIAMA OPERACIJA";
		case "78": res = "78 - NEAPTARNAUTI";
		case "79": res = "79 - NETEISINGAS CVV2 KODAS";
		case "80": res = "80 - AUTORIZACIJOS KLAIDA";
		case "81": res = "81 - PIN KODO áIFRAVIMO KLAIDA";
		case "82": res = "82 - AUTORIZACIJOS KLAIDA";
		case "83": res = "83 - NEGALIMA PATIKRINTI PIN KODO";
		case "84": res = "84 - SISTEMOS KLAIDA";
		case "85": res = "85 - AUTORIZACIJOS KLAIDA";
		case "86": res = "86 - PIN KODO PATIKRINTI NEGALIMA";
		case "87": res = "87 - SISTEMOS KLAIDA";
		case "88": res = "88 - PIN KODO áIFRAVIMO KLAIDA";
		case "89": res = "89 - SISTEMOS KLAIDA";
		case "90": res = "90 - SISTEMOS KLAIDA";
		case "91": res = "91 - KORTEL–S LEID–JAS NEPASIEKIAMAS";
		case "92": res = "92 - KORTEL–S LEID–JAS NEPASIEKIAMAS";
		case "93": res = "93 - OPERACIJA NEGALI BíTI BAIGTA";
		case "94": res = "94 - DUBLIUOJASI PERDAVIMAS";
		case "95": res = "95 - SISTEMOS KLAIDA";
		case "96": res = "96 - SISTEMOS KLAIDA";
		case "97": res = "97 - SISTEMOS KLAIDA";
		case "98": res = "98 - SISTEMOS KLAIDA";
		case "99": res = "99 - TRíKSTA PIN DUOMENö";
		case "CE": res = "CE - NEPAVYKO UëMEGZTI RYáIO";
		case "LC": res = "LC - NEPAVYKO UëMEGZTI RYáIO";
		case "ND": res = "ND - NEPAVYKO UëMEGZTI RYáIO";
		case "TO": res = "TO - NEPAVYKO UëMEGZTI RYáIO";
		case "JF": res = "JF - PAKARTOKIT BANKIN–S DIENOS UëDARYM„";
		case "B1": res = "B1 - AUTORIZACIJOS KLAIDA";
		case "BH": res = "BH - SISTEMOS KLAIDA";
		case "XX": res = "XX - SISTEMOS KLAIDA";
		case "UN": res = "UN - SISTEMOS KLAIDA";
		case "N0": res = "N0 - PRIVERSTINIS STIP";
		case "N1": res = "N1 - OPERACIJA NEGALI BíTI ATLIKTA";
		case "N2": res = "N2 - VIRáYTAS PIN ¯VEDIMO LIMITAS";
		case "N3": res = "N3 - GRYNöJö PINIGö IáMOK–TI NEGALIMA";
		case "N4": res = "N4 - VIRáIJAMAS GRYNöJö PINIGö LIMITAS";
		case "N7": res = "N7 - CVV2 KLAIDA";
		case "N8": res = "N8 - NEPATIKRINTAS CVV KODAS";
		case "N9": res = "N9 - NETEISINGAS CVV KODAS";
		case "NX": res = "NX - ATSISAKYTA KORTEL–S SPRENDIMU";
		case "P2": res = "P2 - NETEISINGA S„SK. INFORMACIJA";
		case "P5": res = "P5 - PIN KEISTI / ATBLOKUOTI NEGALIMA";
		case "P6": res = "P6 - NESAUGUS PIN KODAS";
		case "Q1": res = "Q1 - KORTEL–S PATIKRINTI NEPAVYKO";
		case "R0": res = "R0 - SUSTABDYTI MOK–JIM„";
		case "R1": res = "R1 - OPERACIJOS ATáAUKIMAS";
		case "R3": res = "R3 - VISö OPERACIJö ATáAUKIMAS";
		case "XA": res = "XA - PERSIöSTA KORTEL–S LEID–JUI";
		case "XD": res = "XD - PERSIöSTA KORTEL–S LEID–JUI";
		case "Z1": res = "Z1 - NEAPTARNAUTI";
		case "Z3": res = "Z3 - NEPAVYKO UëMEGZTI RYáIO";
		case "BB": res = "BB - NEAPTARNAUTI";
		case "BD": res = "BD - NEAPTARNAUTI";
		case "DT": res = "DT - NEAPTARNAUTI";
		case "IA": res = "IA - NETEISINGA OPERACIJOS SUMA";
		case "ID": res = "ID - NEAPTARNAUTI";
		case "IM": res = "IM - NEAPTARNAUTI";
		case "IR": res = "IR - NEAPTARNAUTI";
		case "NB": res = "NB - NEAPTARNAUTI";
		case "NC": res = "NC - NEAPTARNAUTI";
		case "NR": res = "NR - NEAPTARNAUTI";
		case "OR": res = "OR - NEAPTARNAUTI";
		case "RE": res = "RE - NEAPTARNAUTI";
		case "T1": res = "T1 - NEAPTARNAUTI";
		case "ZZ": res = "ZZ - NEAPTARNAUTI";
		case "Y1": res = "Y1 - PATVIRTINTA";
		case "Y3": res = "Y3 - PATVIRTINTA";
		otherwise
      res = "NEëINOMA KLAIDA";
  end;
geterror = res;
return;
end;

procedure RemoveCharacterFromString(var string res,string tstr)
BEGIN
  string 1 char;
  string 10 new_char;
  Integer i, n;

  n = len(tstr);
  res = "";
  for (i=0;i<n;i=i+1) begin
    char = Mid(tstr,i,1);
    switch (char) begin
      case "Ó": new_char = """";
      otherwise new_char = char;
    end;
    res = res & new_char;
  end;
  
  RETURN;
END;

enum begin
  FB05_DELAY = 10,
  FB05_LONGDELAY = 30
end;

enum begin
  FB05_STX = 2,
  FB05_ETX = 3,
  FB05_FS = 28
end;

function string 255 NumToHexL(string instr)
begin
  string 255 res;
  string 16 hexs;
  LongInt l,i,m;
  string 255 tstr;
  val inv,v;
  
  hexs = "0123456789ABCDEF";
  inv = StringToVal(instr,M40Val);
  v = inv;
  while (v>=1) begin
    v = v/16;
    l = v;
    m = (v - l)*16;
    res = res & Mid(hexs,m,1);    
  end;
  ReverseString(res,res);
  while (len(res)<8) begin
    res = "0" & res;
  end;
  NumToHexL = res;
  return;
end;

function string 255 NumToHex(string instr)
begin
  string 255 res;
  string 16 hexs;
  LongInt l,i;
  string 255 tstr;
  
  res = "";
  l = FirstInRange(instr,10);
  hexs = "0123456789ABCDEF";
  for (i=0;i<4;i=i+1) begin
    tstr = tstr & Mid(hexs,BitAnd(l,15),1);
    l = l/16;
  end;
  for (i=len(tstr);i>=0;i=i-1) begin
    res = res & Mid(tstr,i,1);
  end;  
  NumToHex = res;
  return;
end;

function Integer FindStrPosition(string tstr,string decsep)
begin
  Integer res;
  Integer i,slen;
  
  slen = len(tstr);
  for (i=slen;i>=0;i=i-1) begin
    if (Mid(tstr,i,1)==decsep) then begin
       res = i;
       goto LFindStrPosition;
    end;
  end;
LFindStrPosition:;  
  FindStrPosition = res;
  return;  
end;

function Integer HexToInt(string instr)
begin
  Integer res;
  string 16 hexs;
  Integer pos,slen,i,t;

  res = 0;
  slen = len(instr);
  hexs = "0123456789ABCDEF";
  for (i=slen;i>0;i=i-1) begin
    pos = FindStrPosition(hexs,Mid(instr,i-1,1));
    res = res + pos*Power(16,(slen-i));
  end; 
  HexToInt = res; 
  return;  
end;

function string 255 CalculateLRC(string CtrlSeq)
begin
  string 255 res;
  Integer i,resi,a;
  
  resi = 0;
  for (i=0;i<len(CtrlSeq);i=i+1) begin
    a = GetByteFromString(Mid(CtrlSeq,i,1),0);
    resi = BitXor(resi,a);
//    resi = BitXor(resi,asc(Mid(CtrlSeq,i,1)));
  end;
  res = NumToHex(resi);
  res = Right(res,2);
  CalculateLRC = res;
  return;
end;

procedure ResetFiscal()
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,cmd;
  
  CtrlSeq = CtrlSeq & "J";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = 0;
  end else begin
    res = 1;
  end;
  return;
end;

function Integer WaitForFB05Receipt(LongInt waittickscoef,var Area aresponse)
begin
  Integer res;
  Integer noErr;
  LongInt waitticks;
  LongInt currenttick, starttick;
  Integer l,responselen;
  Boolean waitf;
  string 255 c,fpresp,errorcode,response;
  Integer pos,i;
  string 255 tstr,tstr2;

  res = noErr;
  response = "";
  waitticks = waittickscoef*1000;
  starttick = GetCurTick;
  response = "";
  
  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;

    c = ReadComPort(0,1);
    response = response & c;
    if (len(response)>=150) then begin
      if (GetAreaLength(aresponse)==0) then begin
        pos = 0;
        ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,tstr);
        ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,response);
      end;
      AddTextToArea(response,aresponse);
      response = "";
    end;

    if (asc(c)==FB05_ETX) then begin
      waitf = false;
    end;    
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
LWaitForFB05Receipt:;
  if (nonblank(response)) then begin
//    response = Left(response,len(response)-2);
    pos = 0;
    ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,tstr);
    ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,tstr2);
    if (nonblank(tstr2)) then begin
      response = tstr;
    end else begin
      response = tstr;
    end;
    AddTextToArea(response,aresponse);
    response = "";
  end;

/*
  errorcode = Right(fpresp,1);
  if (asc(errorcode)!=0) then begin
    res = asc(errorcode);
  end;

  if (asc(errorcode)!=0) then begin
    LogText(0,"WaitForFB05Receipt errorcode " & errorcode & " res " & res);
    ResetFiscal;
  end;
*/  
  if (res==noErr) then begin
    if (GetAreaLength(aresponse)>0) then begin
      res = 1;
    end;
  end;
  WaitForFB05Receipt = res;
  return;
end;

function Integer FB05WriteAndGetReceipt(string CtrlSeq,LongInt delay,var Area aresponse) 
begin
  Integer res;

  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = WaitForFB05Receipt(delay,aresponse);
  end else begin
    res = 1;
  end;
  FB05WriteAndGetReceipt = res;
  return;
end;

function Integer WaitForFB05Reply(LongInt waittickscoef,var string response)
begin
  Integer res;
  Integer noErr;
  LongInt waitticks;
  LongInt currenttick, starttick;
  Integer l,responselen;
  Boolean waitf;
  string 255 c,fpresp,errorcode;
  Integer pos,i;
  string 255 tstr,tstr2;

  res = noErr;
  response = "";
  waitticks = waittickscoef*1000;
  starttick = GetCurTick;

  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;

    c = ReadComPort(0,1);
    response = response & c;

    if (asc(c)==FB05_ETX) then begin
      waitf = false;
    end;    
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
LWaitForFB05Reply:;

  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);

  errorcode = Right(fpresp,1);
  if (asc(errorcode)!=0) then begin
    res = asc(errorcode);
  end;

  if (asc(errorcode)!=0) then begin
    //LogText(0,"WaitForFB05Reply errorcode " & errorcode & " res " & res);
    ResetFiscal;
  end;
  
  if (res==noErr) then begin
    if (blank(errorcode)) then begin
      res = 1;
    end;
  end;
  WaitForFB05Reply = res;
  return;
end;

function Integer FB05Write(string CtrlSeq,LongInt delay) 
begin
  Integer res;
  string 255 response;
  
  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = WaitForFB05Reply(delay,response);
  end else begin
    res = 1;
  end;
  //logtext(0,"write response " & response & " res " & res);
  FB05Write = res;
  return;
end;

function Integer FB05WriteAndGetResponse(string CtrlSeq,LongInt delay,var string response) 
begin
  Integer res;

  response = "";
  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = WaitForFB05Reply(delay,response);
  end else begin
    res = 1;
  end;
  //logtext(0,"WandGet response " & response & "   res  " & res);
  FB05WriteAndGetResponse = res;
  return;
end;
 
procedure SendEscSeqAfter(string EscSeqAfter)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,cmd;
  Integer pos;
  
  if (blank(EscSeqAfter)) then begin
    goto LSendEscSeqAfter;
  end;
  pos = 0;
  ExtractObj(EscSeqAfter,pos,cmd);
  while (nonblank(cmd)) begin
    CtrlSeq = CtrlSeq & uchr(StringToInt(cmd));
    CtrlSeq = CtrlSeq & chr(FB05_FS);
    ExtractObj(EscSeqAfter,pos,cmd);
  end;

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  
  res = FB05Write(CtrlSeq,FB05_DELAY);  
LSendEscSeqAfter:;
  return;
end;
 
global
function Integer FB05GetFiscalData(string command)
begin
  Integer res,msglen;
  string 255 CtrlSeq,msglenhex;  

//<COMMAND>=<0x4F><FS><Õ9Õ><FS>

  msglen = 5 + len(command);
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & command;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));
  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_LONGDELAY);

  FB05GetFiscalData = res;
  return;
end;

function Integer FB05GetFiscalDataResponse(string command,var string response)
begin
  Integer res,msglen;
  string 255 CtrlSeq,msglenhex;  

  response = "";
//<COMMAND>=<0x4F><FS><Õ9Õ><FS>

  msglen = 5 + len(command);
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & command;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));
  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05WriteAndGetResponse(CtrlSeq,FB05_DELAY,response);

  FB05GetFiscalDataResponse = res;
  return;
end;

function Integer GetCopyOfReceipt(string fr,string to,var area aresponse)
begin
  Integer res,msglen,i;
  string 255 CtrlSeq,msglenhex;  

  SetAreaZeroSize(aresponse);

  CtrlSeq = chr(HexToInt("0x61"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & fr;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & to;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05WriteAndGetReceipt(CtrlSeq,FB05_LONGDELAY,aresponse);
  GetCopyOfReceipt = res;
  return;
end;
 
function Integer FB05Open(record LSerialPortDeviceVc LSPDr)
begin
  Integer res;
  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)) then begin
    res = FB05GetFiscalData("3");
    SetComPortCodepage("UTF-8");
  end else begin
    res = 1;
  end;
  FB05Open = res;
  return;
end;

procedure FB05Close()
begin
  Integer res;

  res = CloseComPort(0);
  return;
end;

global function Longint CheckFB05CheckNo()
begin
  INteger msglen,noErr,pos;
  string 255 CtrlSeq,msglenhex,response,fpresp; 
  Date td; 
  Integer pY,pM,pD;
  longint res;
  
//<COMMAND>=<0x4F><FS><Õ2Õ><FS>

  td = CurrentDate;
  msglen = 6;
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x32"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));
  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05WriteAndGetResponse(CtrlSeq,FB05_DELAY,response);
  
  if (res!=noErr) then begin
    if (res>=12400) then begin
      MessageBox(0,USetStr(res));
    end else begin
      MessageBox(0,"error " & USetStr(res));
    end;
    goto LCheckFB05Nr;
  end;
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
LCheckFB05Nr:;
  res = StringToLongInt(fpresp)-1;
  CheckFB05CheckNo = res;
  return;
end;

global function String 255 CheckFB05FiscalNo()
begin
  INteger res,msglen,noErr,pos;
  string 255 CtrlSeq,msglenhex,response,fpresp; 
  Date td; 
  Integer pY,pM,pD;
  
//<COMMAND>=<0x4F><FS><Õ2Õ><FS>

  td = CurrentDate;
  msglen = 6;
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x33"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));
  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05WriteAndGetResponse(CtrlSeq,FB05_DELAY,response);
  
  if (res!=noErr) then begin
    if (res>=12400) then begin
      MessageBox(0,USetStr(res));
    end else begin
      MessageBox(0,"error " & USetStr(res));
    end;
    goto LCheckFB05FiscalNr;
  end;

  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  
LCheckFB05FiscalNr:;
 

  CheckFB05FiscalNo = fpresp;
  return;
end;

function Integer CheckFB05Clock()
begin
  INteger res,msglen,noErr,pos;
  string 255 CtrlSeq,msglenhex,response,fpresp; 
  Date td; 
  Integer pY,pM,pD;

//<COMMAND>=<0x4F><FS><Õ5Õ><FS>

  td = CurrentDate;
  msglen = 6;
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x35"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));
  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05WriteAndGetResponse(CtrlSeq,FB05_DELAY,response);
  
  if (res!=noErr) then begin
    if (res>=12400) then begin
      MessageBox(0,USetStr(res));
    end else begin
      MessageBox(0,"error " & USetStr(res));
    end;
    goto LCheckFB05Clock;
  end;

  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  pY = StringToInt(Left(fpresp,4));
  pM = StringToInt(Mid(fpresp,4,2));
  pD = StringToInt(Mid(fpresp,6,2));
    
  if ((td.year==pY) and (td.month==pM) and (td.day==pD)) then begin
     res = noErr;
  end else begin
     MessageBox(0,USetStr(12402));
     MessageBox(0,USetStr(12403) & pY & pM & pD);
     MessageBox(0,USetStr(12404) & GetYear(td) & GetMonth(td) & GetDay(td));
     res = 12402;
  end;
LCheckFB05Clock:;
  CheckFB05Clock = res;
  return;
end;

function Integer LoadFB05VATRate(string vatrate,var val vr)
begin
  INteger res,msglen,noErr,pos;
  string 255 CtrlSeq,msglenhex,response,fpresp; 

  vr = blankval;
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & vatrate;
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));

  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);
  res = FB05WriteAndGetResponse(CtrlSeq,FB05_DELAY,response);
  if (res!=noErr) then begin
    res = 12405;
    goto LLoadFB05VATRate;
  end;
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  ExtractObjWithSeparator(chr(FB05_FS),response,true,pos,fpresp);
  vr = ValFromString(fpresp,".","");
LLoadFB05VATRate:;
  LoadFB05VATRate = res;
  return;
end;

function Integer LoadFB05VATRates(vector val vatrates)
begin
  Integer res;
  val vr;
  
  res = LoadFB05VATRate("40",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadFB05VATRates;
  end;
  vatrates[0] = vr;
  res = LoadFB05VATRate("41",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadFB05VATRates;
  end;
  vatrates[1] = vr;
  res = LoadFB05VATRate("42",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadFB05VATRates;
  end;
  vatrates[2] = vr;
  res = LoadFB05VATRate("43",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadFB05VATRates;
  end;
  vatrates[3] = vr;
  res = LoadFB05VATRate("44",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadFB05VATRates;
  end;
  vatrates[4] = vr;
  res = LoadFB05VATRate("45",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadFB05VATRates;
  end;
  vatrates[5] = vr;   
LLoadFB05VATRates:;
  LoadFB05VATRates = res;
  return;
end;

function Integer BeginFiscalReceipt()
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;

  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  res = FB05Write(CtrlSeq,FB05_DELAY);
  BeginFiscalReceipt = res;
  return;
end;

procedure CalculatePaymentModeSums(record IVVc IVr,vector val vpaymodesums)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  val t,curval;
  record BaseCurBlock BCbr;

  blockload(BCbr);
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums["CashInCurrency"] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeGiftVoucherPayment] = 0.00;
  vpaymodesums["Lizingas"] = 0.00;
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
          vpaymodesums[kInvoiceRowTypeGiftVoucherPayment] = vpaymodesums[kInvoiceRowTypeGiftVoucherPayment] + IVrw.Sum;
      case kInvoiceRowTypeCreditCardPayment:
      	if IVrw.Spec == "LIZINGAS" then begin
      	  vpaymodesums["Lizingas"] = vpaymodesums["Lizingas"] + IVrw.Sum;
      	end else begin
          vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + IVrw.Sum;
        end;
      case kInvoiceRowTypeCashPayment:
        if IVr.CurncyCode != IVrw.CurncyCode then begin
          vpaymodesums["CashInCurrency"] = vpaymodesums["CashInCurrency"] + IVrw.Sum;
        end else begin
          vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + IVrw.Sum;
        end;
     end;
   end;
   
	switch (IVr.InvType) begin
		case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
		case kInvoiceTypeCredit:
			LkInvoiceTypeCredit:;
//			t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
//			if (t>0) then begin
//				vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
//			end;
		otherwise
//      if curr == true then begin
//        if BCbr.BaseCur1 == BCbr.StdBaseCur then begin
//          t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCreditCardPayment] - curval;
//        end else begin
//          t = IVr.Sum4 - vpaymodesums[kInvoiceRowTypeCreditCardPayment] - curval;
//        end;
//      end else begin
//        t = IVr.Sum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
//      end;
//      if (t>0) then begin
//        if curr == true then begin 
//          vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase2(IVr.CurncyCode,t,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
//        end else begin
//          vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;
//        end;  
//      end;
  end;
  return;
end;

function Integer EndFiscalReceiptCurr(record IVVc IVr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  vector val vpaymodesums;
  
  CalculatePaymentModeSums(IVr,vpaymodesums);
//  if (vpaymodesums[kInvoiceRowTypeCashPayment]<0) or (vpaymodesums[kInvoiceRowTypeCreditCardPayment]<0) then begin
if IVr.InvType == kInvoiceTypeCredit then begin

    CtrlSeq = "7";
//    vpaymodesums[kInvoiceRowTypeCashPayment] = -vpaymodesums[kInvoiceRowTypeCashPayment];
//    vpaymodesums[kInvoiceRowTypeCreditCardPayment] = -vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  end else begin
    CtrlSeq = "2";
  end;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  if vpaymodesums[kInvoiceRowTypeCashPayment] != 0.00 or vpaymodesums[kInvoiceRowTypeGiftVoucherPayment] != 0.00 then begin
    CtrlSeq = CtrlSeq & ValToString(vpaymodesums[kInvoiceRowTypeCashPayment] + vpaymodesums[kInvoiceRowTypeGiftVoucherPayment],M4UVal,"",".",0);
  end else begin
    CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  end;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
//credit card payments  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(vpaymodesums[kInvoiceRowTypeCreditCardPayment],M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(vpaymodesums["Lizingas"],M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
//Cash payments in foreign currency  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  if vpaymodesums["CashInCurrency"] != 0.00 then begin
    CtrlSeq = CtrlSeq & ValToString(vpaymodesums["CashInCurrency"],M4UVal,"",".",0);
  end else begin
    CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  end;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

  res = FB05Write(CtrlSeq,FB05_LONGDELAY);

  FB05GetFiscalData("9");
  EndFiscalReceiptCurr = res;
  return;
end;

function string 255 GetFB05VATCode(Integer InclVAT,string vatcode,vector val vatrates)
begin
  string 255 res;
  val vatprc,tax1;

  if (vatcode=="NE") then begin 			//VS: NE kodas rezervuotas PVM tarifui - NEAPMOKESTIMNAMA
    res = "3"; 
    goto LGetFB05VATCode;
  end;   
  
  GetVATdouble(vatcode,vatprc,tax1,0);		//VS: Is DK param. 'PVM kodai' i vatprc grazinama PVM verte procentais 
  if (vatprc==vatrates[0]) then begin 
    res = "0"; 
    goto LGetFB05VATCode;
  end;
  if (vatprc==vatrates[1]) then begin 
    res = "1"; 
    goto LGetFB05VATCode;
  end;
  if (vatprc==vatrates[2]) then begin 
    res = "2"; 
    goto LGetFB05VATCode;
  end;
  /* if (vatprc==vatrates[3]) then begin 		//VS: Rezervuota PVM tarifui - NEAPMOKESTIMNAMA
    res = "3"; 
    goto LGetFB05VATCode;
  end; */
  if (vatprc==vatrates[4]) then begin 
    res = "4"; 
    goto LGetFB05VATCode;
  end;
  if (vatprc==vatrates[5]) then begin 
    res = "5"; 
    goto LGetFB05VATCode;
  end;
LGetFB05VATCode:;
  GetFB05VATCode = res;
  return;
end;

function Integer DiscountAdditionForItem(record IVVc IVr,row IVVc IVrw)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(-IVrw.vRebate,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  
  res = FB05Write(CtrlSeq,FB05_DELAY);  
  DiscountAdditionForItem = res;
  return;
end;

function Integer PrintRecItem(record IVVc IVr,row IVVc IVrw,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,unit,tstr;
  Area CtrlSeqArea;

  unit = IVrw.UnitCode;
  RemoveCharacterFromString(tstr,IVrw.Spec);
  tstr = Left(tstr,29);				//VS: jei yra daugiau nei 29, fiskalas meta klaida "22"
  if (blank(unit)) then begin
    unit = "PCS";
  end;
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",tstr));	
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  if (IVrw.Quant<0) then begin
    IVrw.Quant = -IVrw.Quant;
  end;
  CtrlSeq = CtrlSeq & ValToString(IVrw.Quant,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(IVrw.Price,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & GetFB05VATCode(IVr.InclVAT,IVrw.VATCode,vatrates);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",unit));
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  

  if (res==noErr) then begin
    if (IVrw.vRebate!=0) then begin
      res = DiscountAdditionForItem(IVr,IVrw);
    end;
  end;
  PrintRecItem = res;
  return;
end;

function Integer PrintRecReturn(record IVVc IVr,row IVVc IVrw,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,unit,tstr;
  Area CtrlSeqArea;

  unit = IVrw.UnitCode;
  if (blank(unit)) then begin
    unit = "PCS";
  end;
  RemoveCharacterFromString(tstr,IVrw.Spec);
  tstr = Left(tstr,29);	
  CtrlSeq = CtrlSeq & "6";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",tstr);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(IVrw.Quant,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(IVrw.Price,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & GetFB05VATCode(IVr.InclVAT,IVrw.VATCode,vatrates);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",unit);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(1.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(2.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  

  PrintRecReturn = res;
  return;
end;

function Integer PrintCommentLine(record IVVc IVr,row IVVc IVrw)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,tstr;
  Area CtrlSeqArea;
  
  RemoveCharacterFromString(tstr,IVrw.Spec);
  tstr = Left(tstr,29);	
  CtrlSeq = CtrlSeq & "C";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x45"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",tstr);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  
  PrintCommentLine = res;
  return;
end;

function Integer PrintItemRows(record IVVc IVr,vector val vatrates)
begin
  INteger res,noErr;
  row IVVc IVrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
			switch (IVrw.stp) begin
				case kInvoiceRowTypeStructuredItemComponent:
					goto LkInvoiceRowTypeNormal1;
				case kInvoiceRowTypeNormal:
	LkInvoiceRowTypeNormal1:;
					if (nonblank(IVrw.ArtCode)) then begin
						res = PrintRecItem(IVr,IVrw,vatrates);
						if (res!=noErr) then begin
							goto LPrintItemRows;
						end;
					end else begin
						res = PrintCommentLine(IVr,IVrw);
						if (res!=noErr) then begin
							goto LPrintItemRows;
						end;
					end;
				case kInvoiceRowTypeVoid:
					res = PrintRecReturn(IVr,IVrw,vatrates);
					if (res!=noErr) then begin
						goto LPrintItemRows;
					end;
			end;
  end;
LPrintItemRows:;  
  PrintItemRows = res;
  return;
end;

//START-CUST   November 17, 2014 by PST
global
procedure FB05GiftReceipt(val sum,val qty,string text,boolean credit)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 
  Area CtrlSeqArea;

  //---Begin non fiscal receipt
  CtrlSeq = "N";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  res = FB05Write(CtrlSeq,FB05_DELAY);
  
  //----Begin Deposit
  CtrlSeq = "d";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",text));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(qty,M4UVal,"",".",0);	
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(sum,M4Val,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  if credit == true then begin
    CtrlSeq = CtrlSeq & "0";
    CtrlSeq = CtrlSeq & chr(FB05_FS);
  end;
  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);
  res = FB05Write(CtrlSeq,FB05_DELAY);    
  
  //---End non fiscal receipt
  CtrlSeq = "E";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  res = FB05Write(CtrlSeq,FB05_DELAY);
  
  //----open cachs drawer
  CtrlSeq = "r";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  res = FB05Write(CtrlSeq,FB05_DELAY);
  
 LFB05MonthlyReport:;  
  return;
end;
//END-CUST November 17, 2014 by PST

function boolean CheckDeposit(record IVVc IVr,record LocalMachineBlock LMb)
begin
  boolean res,credit;
  row IVVc IVrw;
  integer rwcnt,i;
  val giftsum;
  record GCVc GCr;
  
  res = false;
  credit = false;
  giftsum = blankval;
  rwcnt = MatRowCnt(IVr);
	for (i=0;i<rwcnt;i=i+1) begin
	  MatRowGet(IVr,i,IVrw);
	  if IVrw.stp == kInvoiceRowTypeGiftVoucherPayment then begin
	    GCr.SerNr = IVrw.GCNr;
	    ReadFirstMain(GCr,1,true);
	    if GCr.DepositFlag == 1 then begin
	      FB05GiftReceipt(-IVrw.Sum,1,USetStr(18039),false);
	    end else begin
	      FB05GiftReceipt(-IVrw.Sum,1,USetStr(18038),false);
	    end;
	    //i = rwcnt;
	  end;
	  if IVrw.stp == kInvoiceRowTypeGiftVoucherSold then begin
      giftsum = giftsum + IVrw.Sum;
      res = true;
	    GCr.SerNr = IVrw.GCNr;
	    ReadFirstMain(GCr,1,true);
	  end;
	  if IVrw.stp == kInvoiceRowTypeCreditCardPayment then begin
	    credit = true;
	  end;
	  if IVrw.ArtCode == LMb.FiscalPrinterEJournalPath then begin
	    FB05GiftReceipt(-IVrw.Sum,1,USetStr(18039),false);
	    res = true;
	    goto skipf;
	  end;
	end;
	if res == true then begin
	  if credit == true then begin
	    if GCr.DepositFlag == 1 then begin
		    FB05GiftReceipt(giftsum,1,USetStr(18037),true);
		  end else begin
		    FB05GiftReceipt(giftsum,1,USetStr(18036),true);
		  end;
		end else begin
		  if GCr.DepositFlag == 1 then begin
		    FB05GiftReceipt(giftsum,1,USetStr(18037),false);
		  end else begin
		    FB05GiftReceipt(giftsum,1,USetStr(18036),false);
		  end;
		end;
	end;
	skipf:;
CheckDeposit = res;
return;
end;



function Integer PrintRecReturnItem(record IVVc IVr,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,unit,tstr;
  Area CtrlSeqArea;
  record RetItmBlock RetItmb;
  record INVc INr;
  
  blockload(RetItmb);
  
  
  INr.Code = RetItmb.RetItm;
  if ReadFirstmain(INr,1,true) then begin end;
  unit = "VNT";
  RemoveCharacterFromString(tstr,INr.Name);
  tstr = Left(tstr,29);				//VS: jei yra daugiau nei 29, fiskalas meta klaida "22"
  
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",tstr));	
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  CtrlSeq = CtrlSeq & ValToString(1,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(IVr.RetItmPrice1+IVr.RetItmPrice2+IVr.RetItmPrice3+IVr.RetItmPrice4+IVr.RetItmPrice5,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & GetFB05VATCode(IVr.InclVAT,"0",vatrates);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",unit));
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  

  PrintRecReturnItem = res;
  return;
end;

function Integer PrintRetItemRows(record IVVc IVr,vector val vatrates)
begin
  INteger res,noErr;
  Integer i,rwcnt;


  if IVr.RetItmSerNo1 != "" and IVr.RetItmPrice1 > 0 then begin
    res = PrintRecReturnItem(IVr,vatrates);
    if (res!=noErr) then begin
    end;
  end;
	


  PrintRetItemRows = res;
  return;
end;


function Integer EndFiscalItmReturnReceiptCurr(record IVVc IVr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  vector val vpaymodesums;
  
  CtrlSeq = "7";

  CtrlSeq = CtrlSeq & chr(FB05_FS);

  CtrlSeq = CtrlSeq & ValToString(IVr.RetItmPrice1+IVr.RetItmPrice2+IVr.RetItmPrice3+IVr.RetItmPrice4+IVr.RetItmPrice5,M4UVal,"",".",0);

  CtrlSeq = CtrlSeq & chr(FB05_FS);
//credit card payments  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
//Cash payments in foreign currency  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

  res = FB05Write(CtrlSeq,FB05_LONGDELAY);

  FB05GetFiscalData("9");
  EndFiscalItmReturnReceiptCurr = res;
  return;
end;

procedure CheckReturnItm(record IVVc IVr,vector val vatrates)
begin
  Integer noErr,res;
  
  
  if IVr.RetItmSerNo1 != "" and IVr.RetItmPrice1 > 0 then begin
    res = BeginFiscalReceipt;
    if (res!=noErr) then begin
    end; 
    res = PrintRetItemRows(IVr,vatrates);
    if (res!=noErr) then begin
    end;
    res = EndFiscalItmReturnReceiptCurr(IVr);
    if (res!=noErr) then begin
    end;
  end;
return;
end;

global
updating procedure PrintFB05Receipt(var record IVVc IVr,record LSerialPortDeviceVc LSPDr2)
begin
  record IVVc oldIVr;
  Integer noErr,res;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  vector val vatrates;  
  record LSerialPortDeviceVc LSPDr;

  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalPrinter,-1,LMb.LocalMachineCode,LSPDr)==false) then begin  
  end;
  noErr = 0;
  res = FB05Open(LSPDr);
  if (res==noErr) then begin
    noErr = 0;
    //BlockLoad(LMb);
//    MCr.Code = LMb.LocalMachineCode;
//    ReadFirstMain(MCr,1,true);

    res = CheckFB05Clock;
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    res = LoadFB05VATRates(vatrates);	//Proced. uzsiloadina PVM procentus (0..5) is fiskalo
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    
    if CheckDeposit(IVr,LMb) == false then begin
			res = BeginFiscalReceipt;
			if (res!=noErr) then begin
				goto LPrintFB05Receipt;
			end; 
			res = PrintItemRows(IVr,vatrates);
			if (res!=noErr) then begin
				goto LPrintFB05Receipt;
			end;
			res = EndFiscalReceiptCurr(IVr);
			if (res!=noErr) then begin
				goto LPrintFB05Receipt;
			end;
			SendEscSeqAfter(LSPDr.EscSeqAfter);
		end;
    	RecordCopy(oldIVr,IVr);        
		//IVr.ShipAddr3 = CheckFB05FiscalNo;
		IVr.RefStr = CheckFB05CheckNo;  
		IVr.InvComment = "CEKIS";    
		RecordUpdate(oldIVr,IVr,false);  
		CheckReturnItm(IVr,vatrates);
LPrintFB05Receipt:;
    FB05Close;
    SetPOSWindowDisplay_SendToSerialPortDevices("       iDeal       ","");
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

procedure IVCash_CalculatePaymentModeSums(record IVCashVc IVCashr,vector val vpaymodesums)
begin
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  t = IVCashr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (t>0) then begin
    vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
  end;
  return;
end;

function Integer IVCash_EndFiscalReceiptCurr(record IVCashVc IVCashr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  vector val vpaymodesums;

  IVCash_CalculatePaymentModeSums(IVCashr,vpaymodesums);

  if (vpaymodesums[kInvoiceRowTypeCashPayment]<0) or (vpaymodesums[kInvoiceRowTypeCreditCardPayment]<0) then begin
    CtrlSeq = "7";
    vpaymodesums[kInvoiceRowTypeCashPayment] = -vpaymodesums[kInvoiceRowTypeCashPayment];
    vpaymodesums[kInvoiceRowTypeCreditCardPayment] = -vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  end else begin
    CtrlSeq = "2";
  end;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(vpaymodesums[kInvoiceRowTypeCashPayment],M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
//credit card payments  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(vpaymodesums[kInvoiceRowTypeCreditCardPayment],M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
//Cash payments in foreign currency  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

  res = FB05Write(CtrlSeq,FB05_LONGDELAY);

  FB05GetFiscalData("9");
  IVCash_EndFiscalReceiptCurr = res;
  return;
end;

function Integer IVCash_DiscountAdditionForItem(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(-StringToVal(IVCashrw.vRebate,M4UVal),M4UVal,"",".",0); // !! IS NOT VAL ANYMORE
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  
  res = FB05Write(CtrlSeq,FB05_DELAY);  
  IVCash_DiscountAdditionForItem = res;
  return;
end;

function Integer IVCash_PrintRecItem(record IVCashVc IVCashr,row IVCashVc IVCashrw,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  string 255 unit;
  Area CtrlSeqArea;
  
  unit = IVCashrw.UnitCode;
  if (blank(unit)) then begin
    unit = "PCS";
  end;
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",IVCashrw.Spec);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  if (IVCashrw.Quant<0) then begin
    IVCashrw.Quant = -IVCashrw.Quant;
  end;
  CtrlSeq = CtrlSeq & ValToString(IVCashrw.Quant,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(IVCashrw.Price,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & GetFB05VATCode(IVCashr.InclVAT,IVCashrw.VATCode,vatrates);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & unit;
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  
  if (res==noErr) then begin
    // if (IVCashrw.vRebate!=0) then begin
    if (nonblank(IVCashrw.vRebate)) then begin // !! IS NOT VAL ANYMORE
      res = IVCash_DiscountAdditionForItem(IVCashr,IVCashrw);
    end;
  end;
  IVCash_PrintRecItem = res;
  return;
end;

function Integer IVCash_PrintRecReturn(record IVCashVc IVCashr,row IVCashVc IVCashrw,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,unit;
  Area CtrlSeqArea;
  
  unit = IVCashrw.UnitCode;
  if (blank(unit)) then begin
    unit = "PCS";
  end;
  CtrlSeq = CtrlSeq & "6";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",IVCashrw.Spec);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(-IVCashrw.Quant,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(IVCashrw.Price,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & GetFB05VATCode(IVCashr.InclVAT,IVCashrw.VATCode,vatrates);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & unit;
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(1.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(2.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  
  IVCash_PrintRecReturn = res;
  return;
end;

function Integer IVCash_PrintCommentLine(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  Area CtrlSeqArea;
  
  CtrlSeq = CtrlSeq & "C";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x45"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",IVCashrw.Spec);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);  
  IVCash_PrintCommentLine = res;
  return;
end;

function Integer IVCash_PrintItemRows(record IVCashVc IVCashr,vector val vatrates)
begin
  INteger res,noErr;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal2;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal2:;
        if (nonblank(IVCashrw.ArtCode)) then begin
          res = IVCash_PrintRecItem(IVCashr,IVCashrw,vatrates);
          if (res!=noErr) then begin
            goto LPrintItemRows;
          end;
        end else begin
          res = IVCash_PrintCommentLine(IVCashr,IVCashrw);
          if (res!=noErr) then begin
            goto LPrintItemRows;
          end;
        end;
      case kInvoiceRowTypeVoid:
        res = IVCash_PrintRecReturn(IVCashr,IVCashrw,vatrates);
        if (res!=noErr) then begin
          goto LPrintItemRows;
        end;
    end;
  end;
LPrintItemRows:;  
  IVCash_PrintItemRows = res;
  return;
end;

global
updating procedure PrintFB05IVCashReceipt(var record IVCashVc IVCashr,record LSerialPortDeviceVc LSPDr)
begin
  record IVCashVc oldIVCashr;
  Integer noErr,res;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  vector val vatrates;
  
  noErr = 0;
  res = FB05Open(LSPDr);
  if (res==noErr) then begin
    noErr = 0;
    BlockLoad(LMb);
    
//    MCr.Code = LMb.LocalMachineCode;
//    ReadFirstMain(MCr,1,true);

    res = CheckFB05Clock;
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    res = LoadFB05VATRates(vatrates);
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    res = BeginFiscalReceipt;
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    res = IVCash_PrintItemRows(IVCashr,vatrates);
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    res = IVCash_EndFiscalReceiptCurr(IVCashr);
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    SendEscSeqAfter(LSPDr.EscSeqAfter);
    if (IVCashr.Prntdf!=0) then begin
      RecordCopy(oldIVCashr,IVCashr);
      IVCashr.Prntdf = 1;
      RecordUpdate(oldIVCashr,IVCashr,false);
    end;    
LPrintFB05Receipt:;
    FB05Close;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

function Integer MoneyOutCurr(record CashVc Cashr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "Y";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(Cashr.Total,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  
  res = FB05Write(CtrlSeq,FB05_DELAY);  
  MoneyOutCurr = res;
  return;
end;

function Integer MoneyInCurr(record CashVc Cashr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "I";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & ValToString(Cashr.Total,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  
  res = FB05Write(CtrlSeq,FB05_DELAY);  
  MoneyInCurr = res;
  return;
end;

global
procedure PrintFB05CashEvent(var record CashVc Cashr,record LSerialPortDeviceVc LSPDr)
begin
  Integer noErr,res;
  
  noErr = 0;
  res = FB05Open(LSPDr);
  if (res==noErr) then begin    
    res = CheckFB05Clock;
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    switch (Cashr.Event) begin
      case 0:
        MoneyOutCurr(Cashr);
      case 1:
        MoneyInCurr(Cashr);
    end;
LPrintFB05CashEvent:;
    FB05Close;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

//START-CUST   December 1, 2014 by PST
global
procedure PrintFB05GiftReturn(record GCRVc GCRr,record LSerialPortDeviceVc LSPDr)
begin
  Integer noErr,res;
  
  noErr = 0;
  res = FB05Open(LSPDr);
  if (res==noErr) then begin    
    res = CheckFB05Clock;
    if (res!=noErr) then begin
      goto LPrintFB05Receipt;
    end;
    FB05GiftReceipt(-GCRr.Amount,1,USetStr(18046),false);
    FB05Close;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;


//END-CUST December 1, 2014 by PST

function Integer CommitZReport(string FMBCRC32)
begin
  Integer res,msglen,i;
  string 255 CtrlSeq,msglenhex;  

  CtrlSeq = chr(HexToInt("0x75"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & FMBCRC32;
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);

  res = FB05Write(CtrlSeq,FB05_DELAY);

  CommitZReport = res;
  return;
end;

global
procedure FB05DailyReport(record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 
  record LocalMachineBlock LMb;
  string 255 tstr,FMBCRC32,filename,filename2;
  Integer pos;
  LongInt FMBCount,l,NumberOfFirstReceipt;
  Area aresponse;

/*
//  FMBCRC32 = "4280805205";
//  FMBCRC32 = "590";
Trace("FMBCRC32 " & FMBCRC32,"");  
//Trace("STRINGTOLONGINTWRAP(FMBCRC32) " & STRINGTOLONGINTWRAP(FMBCRC32),"");  
//Trace("LongIntToHex(STRINGTOLONGINTWRAP(FMBCRC32)) " & LongIntToHex(STRINGTOLONGINTWRAP(FMBCRC32)),"");  
Trace("NumToHexL(FMBCRC32) " & NumToHexL(FMBCRC32),"");  
//Trace(""," FMBCRC32 " & FMBCRC32 & " LongIntToHex(STRINGTOLONGINTWRAP(FMBCRC32)) " & LongIntToHex(STRINGTOLONGINTWRAP(FMBCRC32)));    
*/

  res = FB05Open(LSPDr);
  if (res!=noErr) then begin
    goto LFB05DailyReport;
  end;
  
  BlockLoad(LMb);
  if (nonblank(LMb.FiscalPrinterEJournalPath)) then begin
    res = FB05GetFiscalDataResponse("3",response);
    res = FB05GetFiscalDataResponse("900",response);
    res = FB05GetFiscalDataResponse("900",response);

    pos = 0;
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
    FMBCount = StringToLongInt(tstr);
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,FMBCRC32);
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
    NumberOfFirstReceipt = StringToLongInt(tstr);

    FMBCRC32 = NumToHexL(FMBCRC32);

  //  filename = LMb.FiscalPrinterEJournalPath & "/" & DateToString(CurrentDate,"YYYYMMDD") & "_" & FMBNumber & "_" & ZNumber & "_" & FMBCRC32 & ".txt";
    filename = LMb.FiscalPrinterEJournalPath & "/" & DateToString(CurrentDate,"YYYYMMDD") & "_" & FMBCRC32 & ".txt";
    CreateFile(filename);
    CloseFile;      
    if (nonblank(LMb.FiscalPrinterEJournalPath2)) then begin
      filename2 = LMb.FiscalPrinterEJournalPath2 & "/" & DateToString(CurrentDate,"YYYYMMDD") & "_" & FMBCRC32 & ".txt";
      CreateFile(filename2);
      CloseFile;      
    end;

    for (l=1;l<=FMBCount;l=l+1) begin
      SetAreaZeroSize(aresponse);    
      res = GetCopyOfReceipt(l,l,aresponse);
      OutAreaToFile(aresponse,filename,1);
      if (nonblank(filename2)) then begin
        OutAreaToFile(aresponse,filename2,1);
      end;
    end;

    res = FB05GetFiscalDataResponse("900",response);

    CtrlSeq = CtrlSeq & "Z";
    CtrlSeq = CtrlSeq & chr(FB05_FS);
    msglen = len(CtrlSeq) + 2;  //msglen and lrc
    msglenhex = NumToHex(msglen);
    msglenhex = Right(msglenhex,2);
    CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;
    CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
    CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
    res = FB05Write(CtrlSeq,FB05_DELAY); 

    res = FB05GetFiscalDataResponse("3",response);
    res = FB05GetFiscalDataResponse("900",response);
    res = FB05GetFiscalDataResponse("900",response);

    pos = 0;
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
    FMBCount = StringToLongInt(tstr);

    SetAreaZeroSize(aresponse);    
    res = GetCopyOfReceipt(FMBCount,FMBCount,aresponse);
    OutAreaToFile(aresponse,filename,1);
    if (nonblank(filename2)) then begin
      OutAreaToFile(aresponse,filename2,1);
    end;    
    res = FB05GetFiscalDataResponse("3",response);
    res = FB05GetFiscalDataResponse("900",response);
    
    pos = 0;
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,tstr);
//    FMBCount = StringToLongInt(tstr);
    ExtractObjWithSeparator(chr(FB05_FS),response,false,pos,FMBCRC32);

    FMBCRC32 = NumToHexL(FMBCRC32);

    res = FB05GetFiscalDataResponse("3",response);
    res = FB05GetFiscalDataResponse("7",response);
    res = FB05GetFiscalDataResponse("9",response);
    res = FB05GetFiscalDataResponse("900",response);
    res = FB05GetFiscalDataResponse("900",response);

    CommitZReport(FMBCRC32);    
  end else begin
    CtrlSeq = CtrlSeq & "Z";
    CtrlSeq = CtrlSeq & chr(FB05_FS);

    msglen = len(CtrlSeq) + 2;  //msglen and lrc
    msglenhex = NumToHex(msglen);
    msglenhex = Right(msglenhex,2);
    CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

    CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
    CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

    res = FB05Write(CtrlSeq,FB05_DELAY); 
  end;
    
  
 LFB05DailyReport:;  
  FB05Close;
  return;
end;

global
procedure FB05MonthlyReport(record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 

  res = FB05Open(LSPDr);
  if (res!=noErr) then begin
    goto LFB05MonthlyReport;
  end;
  
  CtrlSeq = CtrlSeq & "X";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

  res = FB05Write(CtrlSeq,FB05_DELAY); 
  FB05Close;
 LFB05MonthlyReport:;  
  return;
end;

global
procedure FB05PeriodicReport(record RcVc RepSpec,record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 

  res = FB05Open(LSPDr);
  if (res!=noErr) then begin
    goto LFB05PeriodicReport;
  end;
  
  CtrlSeq = CtrlSeq & "F";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & DateToString(RepSpec.d1,"YYYYMMDD");
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & DateToString(RepSpec.d2,"YYYYMMDD");
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    

  res = FB05Write(CtrlSeq,FB05_DELAY); 
  FB05Close;
 LFB05PeriodicReport:;  
  return;
end;

global
procedure SetPOSWindowDisplay_Generic(record LSerialPortDeviceVc LSPDr,string dispstr,string disp2str)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  Area CtrlSeqArea;
  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)) then begin
    SetComPortCodepage(StringSetFromString(89,LSPDr.Codepage));
    CtrlSeq = chr(12); //0x0C
    res = OutComPort(0,CtrlSeq);
    
    if (blank(dispstr)) and (blank(disp2str)) then begin
      SetComPortCodepage("UTF-8");
      res = CloseComPort(0);
      goto LSetPOSWindowDisplay_Generic;
    end;
    CtrlSeq = "";
    if (nonblank(dispstr)) then begin
      CtrlSeq = CtrlSeq & chr(8);  //0x08
      M4PadString(Left(dispstr,19),20," ",true,tstr);//20 doesnt want to work nicely
      CtrlSeq = CtrlSeq & tstr;
    end;

    if (nonblank(disp2str)) then begin
      if (nonblank(dispstr)) then begin
        CtrlSeq = CtrlSeq & chr(9);
      end else begin
        CtrlSeq = CtrlSeq & chr(10);  //0x0A
      end;
      M4PadString(Left(disp2str,20),20," ",true,tstr);
      CtrlSeq = CtrlSeq & tstr;
    end;

    res = OutComPort(0,CtrlSeq);
    
    res = CloseComPort(0);
    SetComPortCodepage("UTF-8");
  end;
LSetPOSWindowDisplay_Generic:;  
  return;
end;

global
procedure SetPOSWindowDisplay_Posiflex(record LSerialPortDeviceVc LSPDr,string dispstr,string disp2str)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  Area CtrlSeqArea;
  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)) then begin
    SetComPortCodepage(StringSetFromString(89,LSPDr.Codepage));//set Codepage 866
    if (StringSetFromString(89,LSPDr.Codepage)=="CP866") then begin
      CtrlSeq = chr(27) & chr(116) & chr(6); //set Codepage 866
    end;
    res = OutComPort(0,CtrlSeq);
    CtrlSeq = chr(12); //0x0C
    res = OutComPort(0,CtrlSeq);
    CtrlSeq = chr(11); //0x0B
    res = OutComPort(0,CtrlSeq);
    
    if (blank(dispstr)) and (blank(disp2str)) then begin
      SetComPortCodepage("UTF-8");
	    res = CloseComPort(0);
      goto LSetPOSWindowDisplay_Posiflex;
    end;
    CtrlSeq = "";
    if (nonblank(dispstr)) then begin
      CtrlSeq = CtrlSeq & chr(8);  //0x08
      M4PadString(Left(dispstr,19),20," ",true,tstr);//20 doesnt want to work nicely
      CtrlSeq = CtrlSeq & tstr;
    end;

    if (nonblank(disp2str)) then begin
      if (nonblank(dispstr)) then begin
        CtrlSeq = CtrlSeq & chr(9);
      end else begin
        CtrlSeq = CtrlSeq & chr(10);  //0x0A
      end;
      M4PadString(Left(disp2str,20),20," ",true,tstr);
      CtrlSeq = CtrlSeq & tstr;
    end;

    res = OutComPort(0,CtrlSeq);
    
    res = CloseComPort(0);
    SetComPortCodepage("UTF-8");
  end;
LSetPOSWindowDisplay_Posiflex:;  
  return;
end;

function string 40 MakeLine(string text1,string text2)
begin
	string 40 res;
	integer i;
	
	i = 40 - len(text1) - len(text2);
	switch(i) begin
		case 1: res = text1 & " " & text2;
		case 2: res = text1 & "  " & text2;
		case 3: res = text1 & "   " & text2;
		case 4: res = text1 & "    " & text2;
		case 5: res = text1 & "     " & text2;
		case 6: res = text1 & "      " & text2;
		case 7: res = text1 & "       " & text2;
		case 8: res = text1 & "        " & text2;
		case 9: res = text1 & "         " & text2;
		case 10: res = text1 & "          " & text2;
		case 11: res = text1 & "           " & text2;
		case 12: res = text1 & "            " & text2;
		case 13: res = text1 & "             " & text2;
		case 14: res = text1 & "              " & text2;
		case 15: res = text1 & "               " & text2;
		case 16: res = text1 & "                " & text2;
		case 17: res = text1 & "                 " & text2;
		case 18: res = text1 & "                  " & text2;
		case 19: res = text1 & "                   " & text2;
		case 20: res = text1 & "                    " & text2;
    case 21: res = text1 & "                     " & text2;
		case 22: res = text1 & "                      " & text2;
		case 23: res = text1 & "                       " & text2;
		case 24: res = text1 & "                        " & text2;
		case 25: res = text1 & "                         " & text2;
		case 26: res = text1 & "                          " & text2;
		case 27: res = text1 & "                           " & text2;
		case 28: res = text1 & "                            " & text2;
		case 29: res = text1 & "                             " & text2;
		case 30: res = text1 & "                              " & text2;
		case 31: res = text1 & "                               " & text2;
		case 32: res = text1 & "                                " & text2;
		case 33: res = text1 & "                                 " & text2;
		case 34: res = text1 & "                                  " & text2;
		case 35: res = text1 & "                                   " & text2;
		case 36: res = text1 & "                                    " & text2;
		case 37: res = text1 & "                                     " & text2;
	end;
  MakeLine = res;
return;
end;

function string 20 MakeLine2(string text1,string text2)
begin
	string 40 res;
	integer i;
	
	i = 20 - len(text1) - len(text2);
	switch(i) begin
		case 1: res = text1 & " " & text2;
		case 2: res = text1 & "  " & text2;
		case 3: res = text1 & "   " & text2;
		case 4: res = text1 & "    " & text2;
		case 5: res = text1 & "     " & text2;
		case 6: res = text1 & "      " & text2;
		case 7: res = text1 & "       " & text2;
		case 8: res = text1 & "        " & text2;
		case 9: res = text1 & "         " & text2;
		case 10: res = text1 & "          " & text2;
		case 11: res = text1 & "           " & text2;
		case 12: res = text1 & "            " & text2;
		case 13: res = text1 & "             " & text2;
		case 14: res = text1 & "              " & text2;
		case 15: res = text1 & "               " & text2;
		case 16: res = text1 & "                " & text2;
		case 17: res = text1 & "                 " & text2;
		case 18: res = text1 & "                  " & text2;
		case 19: res = text1 & "                   " & text2;
	end;
  MakeLine2 = res;
return;
end;

global
procedure FB05PinPadLine(string text)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 
  Area CtrlSeqArea;
  
  CtrlSeq = "A";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x40"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",text));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  
  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);
  res = FB05Write(CtrlSeq,FB05_DELAY); 
return;
end;

global
procedure FB05PinPadLineBold(string text)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 
  Area CtrlSeqArea;
  
  CtrlSeq = "A";
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x68"));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  CtrlSeq = CtrlSeq & (ConvertStringToCodePage("CP1257",text));
  CtrlSeq = CtrlSeq & chr(FB05_FS);
  
  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(FB05_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(FB05_ETX);
  res = FB05Write(CtrlSeq,FB05_DELAY); 
return;
end;

function string 15 RemoveSpaces(string text)
begin
  string 15 res;
  integer i;
  string 1 a;
  
  for (i=0;i<len(text);i=i+1) begin
  	a = mid(text,i,1);
    if asc(a) > 47 then begin
    	res = res & a;
    end;
  end;

RemoveSpaces = res;
return;
end;

function string 40 MildText(string text)
begin
  string 40 res;
  integer i;
  string 1 a;
  
	i = len(text);
	switch(i) begin
		case 10: res = "               " & text & "              ";
		case 12: res = "              " & text & "              ";
		case 13: res = "              " & text & "             ";
		case 14: res = "             " & text & "             ";
		case 15: res = "             " & text & "            ";
		case 16: res = "            " & text & "            ";
		case 17: res = "            " & text & "           ";
		case 18: res = "           " & text & "           ";
		case 19: res = "           " & text & "          ";
		case 20: res = "          " & text & "          ";
		case 21: res = "          " & text & "         ";
		case 22: res = "         " & text & "         ";
		case 23: res = "         " & text & "        ";
		case 24: res = "        " & text & "        ";
		case 25: res = "        " & text & "       ";
		case 26: res = "       " & text & "       ";
		case 27: res = "       " & text & "      ";
		case 28: res = "      " & text & "      ";
		case 29: res = "      " & text & "     ";
		case 30: res = "     " & text & "     ";
		case 31: res = "     " & text & "    ";
		case 32: res = "    " & text & "    ";
		case 33: res = "    " & text & "   ";
		case 34: res = "   " & text & "   ";
		case 35: res = "   " & text & "  ";
		case 36: res = "  " & text & "  ";
		case 37: res = "  " & text & " ";
		case 38: res = " " & text & " ";
		case 39: res = " " & text & "";
		case 40: res =  text;
		case 41: res =  text;
		otherwise
			res = text;
	end;

MildText = res;
return;
end;

function string 15 MakeAmount(string text)
begin
  string 15 res,res1;
  integer i;
  string 1 a;
  string 2 temp;
  boolean testf;
  
  temp = right(text,2);
  res1 = left(text,len(text)-2);
  for (i=0;i<len(res1);i=i+1) begin
  	a = mid(res1,i,1);
    if a != "0"  then begin
    	testf = true;
    end;
    if testf == true then begin
    	res = right(res1,len(res1)-i);
    	i = len(res1);
    end;
  end;
  if testf == false then begin
    res = res & "0." & temp;
  end else begin
    res = res & "." & temp;
  end;
MakeAmount = res;
return;
end;

procedure FB05PinPad(var array string text,string type,var boolean printsecond,var array string text2)
begin
  integer res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 
  Area CtrlSeqArea;
  
  SetLangMode(LangLithuanian, "LIT", 0);
  
  //---Begin non fiscal receipt
  CtrlSeq = "N";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  res = FB05Write(CtrlSeq,FB05_DELAY);
  
  //----Begin Lines
  FB05PinPadLine(USetStr(18122));
  text2[0] = USetStr(18122);
  FB05PinPadLine(MakeLine("TERMINALO NR.:",text[15]));
  text2[1] = MakeLine("TERMINALO NR.:",text[15]);
  FB05PinPadLine(MakeLine("PREKYBININKO NR.:",RemoveSpaces(text[9])));
  text2[2] = MakeLine("PREKYBININKO NR.:",RemoveSpaces(text[9]));
  FB05PinPadLine(right(text[8],len(text[8])-20) & "  (C)");
  text2[3] = right(text[8],len(text[8])-20) & "  (C)";
  FB05PinPadLine("                        ");
  text2[4] = "                        ";
  FB05PinPadLine(left(text[7],16));
  text2[5] = left(text[7],16);
  FB05PinPadLine(MakeLine("BYLA: " & text[16],"KVITO NR: " & left(text[8],6)));
  text2[6] = MakeLine("BYLA: " & text[16],"KVITO NR: " & left(text[8],6));
  FB05PinPadLine(MakeLine("DATA: " & DateToString(currentdate,"YYYY-MM-DD"),"LAIKAS: " & currenttime));
  text2[7] = MakeLine("DATA: " & DateToString(currentdate,"YYYY-MM-DD"),"LAIKAS: " & currenttime);
  FB05PinPadLine("RRN: " & text[4]);
  text2[8] = "RRN: " & text[4];
  FB05PinPadLine(MakeLine("AID: " & text[12],"APP: " & RemoveSpaces(text[17])));
  text2[9] = MakeLine("AID: " & text[12],"APP: " & RemoveSpaces(text[17]));
  FB05PinPadLine("AAC: " & text[13]);
  text2[10] = "AAC: " & text[13];
  FB05PinPadLine(MakeLine("TVR: " & text[14],"TSI: " & text[26]));
  text2[11] = MakeLine("TVR: " & text[14],"TSI: " & text[26]);
  if text[19] == "Y" then begin
    printsecond = true;
  	switch(type) begin
		  case "PARD": FB05PinPadLineBold("     PARDAVIMAS     ");
		  	text2[12] = "     PARDAVIMAS     ";
		  case "REF":  FB05PinPadLineBold("     GR„ëINIMAS     ");
		    text2[12] = "     GR„ëINIMAS     ";
		  case "VOID": FB05PinPadLineBold("     ATSISAKYMAS    ");
		    text2[12] = "     ATSISAKYMAS    ";
		end;
		FB05PinPadLine("                        ");
		text2[13] = "                        ";
		FB05PinPadLineBold(MakeLine2("SUMA:",MakeAmount(text[3]) & " EUR"));
		text2[14] = MakeLine("SUMA:",MakeAmount(text[3]) & " EUR");
		FB05PinPadLine("                        ");
		text2[15] = "                        ";
		switch(type) begin
		  case "PARD":
			switch(mid(text[11],2,1)) begin
				case "P":
					FB05PinPadLine(USetStr(18129));
					FB05PinPadLine("                        ");
					text2[16] = USetStr(18129);
					text2[17] = "                        ";
				case "S":
					FB05PinPadLine(USetStr(18130));
					FB05PinPadLine("                        ");
					text2[16] = USetStr(18130);
					text2[17] = "                        ";
					printsecond = true;
				case "C":
					FB05PinPadLine(USetStr(18129));
					FB05PinPadLine("                        ");
					FB05PinPadLine(USetStr(18130));
					FB05PinPadLine("                        ");
					text2[16] = USetStr(18129);
					text2[17] = "                        ";
					text2[18] = USetStr(18130);
					text2[19] = "                        ";
					printsecond = true;
			end;
		  case "REF": 
		    FB05PinPadLine(USetStr(18131));
		    FB05PinPadLine("                        ");
				text2[16] = USetStr(18131);
				text2[17] = "                        ";
		  case "VOID":
		end;
		FB05PinPadLineBold(USetStr(18128));
		FB05PinPadLine("                        ");
		FB05PinPadLine(USetStr(18126));
		FB05PinPadLine(USetStr(18127));
		FB05PinPadLine("                        ");
		text2[18] = USetStr(18128);
		text2[19] = "                        ";
		text2[20] = USetStr(18126);
		text2[21] = USetStr(18127);
		text2[22] = "                        ";
  end else begin
  	switch(type) begin
		  case "PARD": FB05PinPadLineBold("     PARDAVIMAS     ");
		    text2[12] = "     PARDAVIMAS     ";
		  case "REF":  FB05PinPadLineBold("     GR„ëINIMAS     ");
		    text2[12] = "     GR„ëINIMAS     ";
		  case "VOID": FB05PinPadLineBold("     ATSISAKYMAS    ");
		    text2[12] = "     ATSISAKYMAS    ";
		end;
    FB05PinPadLine("                        ");
    text2[13] = "                        ";
    FB05PinPadLineBold(MakeLine2("SUMA:",MakeAmount(text[3]) & " EUR"));
    text2[14] = MakeLine("SUMA:",MakeAmount(text[3]) & " EUR");
    FB05PinPadLine("                        ");
    text2[15] = "                        ";
    FB05PinPadLineBold(USetStr(18125));
    text2[16] = USetStr(18125);
    FB05PinPadLine(MildText(geterror(right(text[0],2))));
    text2[17] = MildText(geterror(right(text[0],2)));
    FB05PinPadLine(USetStr(18123));
    text2[18] = USetStr(18123);
    FB05PinPadLine(USetStr(18124));
    text2[19] = USetStr(18124);
    FB05PinPadLine("                        ");
  end;
  
  //---End non fiscal receipt
  CtrlSeq = "E";
  CtrlSeq = CtrlSeq & chr(FB05_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(FB05_STX) & CtrlSeq & chr(FB05_ETX);    
  res = FB05Write(CtrlSeq,FB05_DELAY);
  
 LFB05MonthlyReport:;  
  return;
end;

global
function boolean PrintPinPadReceipt(array string response,string type,array string text2)
begin
  Integer noErr,res;
  record LSerialPortDeviceVc LSPDr;
  string 255 CtrlSeq;
  integer wn,rwcnt,i;
  record LocalMachineBlock LMb;
  boolean printsecond;

  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalPrinter,-1,LMb.LocalMachineCode,LSPDr)==false) then begin  
  end;
  
  noErr = 0;
  res = FB05Open(LSPDr);
  printsecond = false;
  FB05PinPad(response,type,printsecond,text2);
  if printsecond == true then begin
    FB05PinPad(response,type,printsecond,text2);
  end;
  FB05Close;
return;
end;